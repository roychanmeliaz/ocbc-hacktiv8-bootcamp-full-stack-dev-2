# -*- coding: utf-8 -*-
"""Python_Files.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JNh8JltpES0JsRz2Md38F5f4hCsY5p-2

# Files

## What Is a File?

Before we can go into how to work with files in Python, it’s important to understand what exactly a file is and how modern operating systems handle some of their aspects.

At its core, a file is a contiguous set of bytes used to store data. This data is organized in a specific format and can be anything as simple as a text file or as complicated as a program executable. In the end, these byte files are then translated into binary 1 and 0 for easier processing by the computer.

Files on most modern file systems are composed of three main parts:

- Header: metadata about the contents of the file (file name, size, type, and so on)
- Data: contents of the file as written by the creator or editor
- End of file (EOF): special character that indicates the end of the file

## File Paths

When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts:

- Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash / (Unix) or backslash \ (Windows)
- File Name: the actual name of the file
- Extension: the end of the file path pre-pended with a period (.) used to indicate the file type

Here’s a quick example. Let’s say you have a file located within a file structure like this:

```sh
/
│
├── path/
|   │
│   ├── to/
│   │   └── H8cats.gif
│   │
│   └── H8dog_breeds.txt
|
└── H8animals.csv
```

Let’s say you wanted to access the cats.gif file, and your current location was in the same folder as path. In order to access the file, you need to go through the path folder and then the to folder, finally arriving at the cats.gif file. The Folder Path is path/to/. The File Name is cats. The File Extension is .gif. So the full path is path/to/cats.gif.

## Opening and Closing a File in Python

When you want to work with a file, the first thing to do is to open it. This is done by invoking the open() built-in function. open() has a single required argument that is the path to the file. open() has a single return, the file object:

(you can download sample file [here](https://raw.githubusercontent.com/ardhiraka/PFDS_sources/master/Hack8_Sample_Text.txt))
"""

file = open('Hack8_Sample_Text.txt')

"""After you open a file, the next thing to learn is how to close it.

**Warning: You should always make sure that an open file is properly closed.**
"""

file.close()

"""A safer way is to use a try...finally block."""

try:
   f = open("Hack8_Sample_Text.txt", encoding = 'utf-8')
   # perform file operations
finally:
   f.close()

"""## Text File Types

A text file is the most common file that you’ll encounter. Here are some examples of how these files are opened:

```py
open('abc.txt')

open('abc.txt', 'r')

open('abc.txt', 'w')
```

## Buffered Binary File Types

A buffered binary file type is used for reading and writing binary files. Here are some examples of how these files are opened:

```
open('abc.txt', 'rb')

open('abc.txt', 'wb')
```

## Raw File Types

A raw file type is:

“generally used as a low-level building-block for binary and text streams.” (Source)

It is therefore not typically used.

Here’s an example of how these files are opened:

`open('abc.txt', 'rb', buffering=0)`

## Writing to Files in Python

In order to write into a file in Python, we need to open it in write w, append a or exclusive creation x mode.

We need to be careful with the w mode, as it will overwrite into the file if it already exists. Due to this, all the previous data are erased.

Writing a string or sequence of bytes (for binary files) is done using the write() method. This method returns the number of characters written to the file.
"""

with open("sample.txt",'w',encoding = 'utf-8') as f:
   f.write("my first file\n")
   f.write("This file\n\n")
   f.write("contains three lines\n")

"""This program will create a new file named test.txt in the current directory if it does not exist. If it does exist, it is overwritten.

We must include the newline characters ourselves to distinguish the different lines.

## Reading Files in Python

To read a file in Python, we must open the file in reading r mode.

There are various methods available for this purpose. We can use the read(size) method to read in the size number of data. If the size parameter is not specified, it reads and returns up to the end of the file.

We can read the text.txt file we wrote in the above section in the following way:
"""

f = open("sample.txt",'r',encoding = 'utf-8')

f.read(4) # read the first 4 data

f.read(4)    # read the next 4 data

f.read()     # read in the rest till end of file

f.read()  # further reading returns empty sting

"""We can see that the read() method returns a newline as '\n'. Once the end of the file is reached, we get an empty string on further reading.

We can change our current file cursor (position) using the seek() method. Similarly, the tell() method returns our current position (in number of bytes).
"""

f.tell()    # get the current file position

f.seek(0)   # bring file cursor to initial position

print(f.read())  # read the entire file

"""We can read a file line-by-line using a for loop. This is both efficient and fast.


"""

f.seek(0)   # bring file cursor to initial position
for line in f:
  print(line, end = '')

"""Alternatively, we can use the readline() method to read individual lines of a file. This method reads a file till the newline, including the newline character.


"""

f.seek(0)
f.readline()

"""Here’s an example of how to open and read the entire file using .read():


"""

with open('sample.txt', 'r') as reader:
     # Read & print the entire file
     print(reader.read())

"""# Exception

## Raising an Exception

We can use raise to throw an exception if a condition occurs. The statement can be complemented with a custom exception.

If you want to throw an error when a certain condition occurs using raise, you could go about it like this:
"""

x = 10
if x > 5:
    raise Exception('x should not exceed 5. The value of x was: {}'.format(x))

x = 10
if x > 5:
    raise Exception('your custom exception')

"""## The AssertionError Exception

Instead of waiting for a program to crash midway, you can also start by making an assertion in Python. We assert that a certain condition is met. If this condition turns out to be True, then that is excellent! The program can continue. If the condition turns out to be False, you can have the program throw an AssertionError exception.
"""

import sys
assert ('linux' in sys.platform), "This code runs on Linux only."
assert ('windows' in sys.platform), "This code runs on Windows only."

"""## The try and except Block: Handling Exceptions

The try and except block in Python is used to catch and handle exceptions. Python executes code following the try statement as a “normal” part of the program. The code that follows the except statement is the program’s response to any exceptions in the preceding try clause.
"""

def os_interaction():
    assert ('linux' in sys.platform), "Function can only run on Linux systems."
    assert ('windows' in sys.platform), "This code runs on Windows only."
    print('Doing something.')

"""The os_interaction() can only run on a Linux or Windows system. The assert in this function will throw an AssertionError exception if you call it on an operating system other then Linux.

You can give the function a try using the following code:
"""

try:
    os_interaction()
except:
    pass

"""The way you handled the error here is by handing out a pass."""

try:
    os_interaction()
except:
    print('Windows function was not executed')

"""When an exception occurs in a program running this function, the program will continue as well as inform you about the fact that the function call was not successful.

What you did not get to see was the type of error that was thrown as a result of the function call. In order to see exactly what went wrong, you would need to catch the error that the function threw.

The following code is an example where you capture the AssertionError and output that message to screen:
"""

try:
    os_interaction()
except AssertionError as error:
    print(error)
    print('The os_interaction() function was not executed')

# Here’s another example where you open a file and use a built-in exception:

try:
    with open('file.log') as file:
        read_data = file.read()
except:
    print('Could not open file.log')

"""This is an informative message, and our program will still continue to run. In the Python docs, you can see that there are a lot of built-in exceptions that you can use here. One exception described on that page is the following:

`Exception FileNotFoundError`

Raised when a file or directory is requested but doesn’t exist. Corresponds to errno ENOENT.

To catch this type of exception and print it to screen, you could use the following code:
"""

try:
    with open('file.log') as file:
        read_data = file.read()
except FileNotFoundError as fnf_error:
    print(fnf_error)

"""Look at the following code. Here, you first call the os_interaction() function and then try to open a file:"""

try:
    os_interaction()
    with open('file.log') as file:
        read_data = file.read()
except FileNotFoundError as fnf_error:
    print(fnf_error)
except AssertionError as error:
    print(error)
    print('os_interaction() function was not executed')

"""## The else Clause

In Python, using the else statement, you can instruct a program to execute a certain block of code only in the absence of exceptions.


"""

try:
    os_interaction()
except AssertionError as error:
    print(error)
else:
    print('Executing the else clause.')

"""Because the program did not run into any exceptions, the else clause was executed.

You can also try to run code inside the else clause and catch possible exceptions there as well:
"""

try:
    os_interaction()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)

"""## Cleaning Up After Using finally

Imagine that you always had to implement some sort of action to clean up after executing your code. Python enables you to do so using the finally clause.
"""

# Have a look at the following example:

try:
    os_interaction()
except AssertionError as error:
    print(error)
else:
    try:
        with open('file.log') as file:
            read_data = file.read()
    except FileNotFoundError as fnf_error:
        print(fnf_error)
finally:
    print('Cleaning up, irrespective of any exceptions.')

"""In the previous code, everything in the finally clause will be executed. It does not matter if you encounter an exception somewhere in the try or else clauses."""